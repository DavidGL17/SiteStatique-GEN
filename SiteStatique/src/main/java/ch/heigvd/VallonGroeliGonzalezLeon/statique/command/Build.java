/*
 * @File Build.java
 * @Authors : David González León, Jade Gröli, Axel Vallon
 * @Date 5 mars 2021
 */
package ch.heigvd.VallonGroeliGonzalezLeon.statique.command;


import ch.heigvd.VallonGroeliGonzalezLeon.statique.command.api.TemplateHTML;
import ch.heigvd.VallonGroeliGonzalezLeon.statique.util.Util;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import picocli.CommandLine;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.concurrent.Callable;


/**
 * The build command. This command build the static site. It is also possible to ask that the command keep running
 * after building to keep building every time a change is made.
 */
@CommandLine.Command(name = "build", mixinStandardHelpOptions = true,
                     description = "Builds the site using the given markdown and json files. This command needs to be" +
                                   " executed at the root of the directory generated by the init command.\n" +
                                   "If there are any images that are in the same directory as the markdown and json " +
                                   "files, they will be copied to the corresponding build file.\n" +
                                   "If the config file, the layout file or the main md file are missing from their" +
                                   " normal location, the command will return 1\n" +
                                   "In case of an error while writing or reading the command will return 2\n" +
                                   "The program will also compile all md files in subdirectories of the current " +
                                   "directory. ")
public class Build implements Callable<Integer> {

   /**
    * The watching option, enables continuous building
    */
   @CommandLine.Option(names = {"-w", "--watching"},
                       description = "Enables background continuous analysis of the project") boolean watching;
   /**
    * The site path, an option that allows to specify the path, if the command is not used in the base directory of the
    * project
    */
   @CommandLine.Option(names = {"-p", "--path"}, description = "Specific path to main directory") String sitePath;

   @Override
   public Integer call() {
      System.out.println("Starting build...");
      File baseDirectory;
      try {
         String path = new File(".").getCanonicalPath();
         if (sitePath != null) {
            path += sitePath;
         }
         baseDirectory = new File(path);
      } catch (IOException e) {
         System.err.println("Error while reading current directory");
         e.printStackTrace();
         return 2;
      }
      File buildDirectory = new File(baseDirectory.getPath() + "\\build");
      if (buildDirectory.exists()) {
         try {
            FileUtils.deleteDirectory(buildDirectory);
         } catch (IOException e) {
            e.printStackTrace();
            System.err.println("Build directory deletion failure.");
         }
      }
      if (!buildDirectory.mkdir()) {
         System.err.println("Error while creating the build directory");
         return 1;
      }

      File jsonFile = new File(baseDirectory.getPath() + "/config.json");
      if (!jsonFile.exists()) {
         System.err.println("Config file missing");
         return 1;
      }

      File layoutFile = new File(baseDirectory.getPath() + "/template/layout.html");
      if (!layoutFile.exists()) {
         System.err.println("Layout file missing");
         return 1;
      }

      File mdIndexFile = new File(baseDirectory.getPath() + "/index.md");
      if (!mdIndexFile.exists()) {
         System.err.println("Main md file missing");
         return 1;
      }
      TemplateHTML templateHTML;
      try {
         templateHTML = new TemplateHTML(layoutFile, jsonFile);
      } catch (IOException e) {
         System.err.println("Error while reading the layout and config file");
         return 2;
      }

      try {
         buildAll(templateHTML, mdIndexFile, baseDirectory, buildDirectory);
      } catch (IOException e) {
         return 2;
      }
      System.out.println("Build done.");

      if (!watching) {
         return 0;
      }
      /*
       * Le build continu se fait sur 4 types de fichiers et suit les règles suivantes :
       *
       * - md : recompiler fichier on create,modify et supprimer si delete
       * - json,template : tout recompiler on modify et lancer une erreur on delete
       * - images : déplacer dans le dossier build correspondant on create, modify, supprimer on delete
       * - dir : compiler le dossier en cas de création, supprime en cas de delete, et changer le nom du dossier
       * build en cas de modify
       */
      try {
         WatchService watcher = FileSystems.getDefault().newWatchService();
         Path dir = baseDirectory.toPath();
         Files.walkFileTree(dir, new FileVisitor<Path>() {
            @Override
            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {
               //ajouter les modifs de build
               if (dir.getFileName().toString().equals("build")) {
                  return FileVisitResult.SKIP_SUBTREE;
               }
               return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
               return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult visitFileFailed(Path file, IOException exc) {
               return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult postVisitDirectory(Path dir, IOException exc) {
               return FileVisitResult.CONTINUE;
            }
         });
         dir.register(watcher, StandardWatchEventKinds.ENTRY_CREATE, StandardWatchEventKinds.ENTRY_DELETE,
                      StandardWatchEventKinds.ENTRY_MODIFY);
         System.out.println("The continuous building function is launching...\nPlease do not delete or move the " +
                            "config.json file or the layout.html file.");
         while (true) {
            WatchKey key = watcher.take();
            while (key != null) {
               for (WatchEvent<?> event : key.pollEvents()) {
                  WatchEvent<Path> ev = (WatchEvent<Path>) event;
                  Path filename = dir.resolve(ev.context());
                  switch (FileType.getFileTypeFromFile(filename.toFile(), baseDirectory)) {
                     case MD:
                        handleMd(ev, baseDirectory, templateHTML);
                        break;
                     case IMAGE:
                        handleImage(ev, baseDirectory);
                        break;
                     case CONFIG:
                     case LAYOUT:
                        templateHTML =
                                handleConfigAndLayout(ev, templateHTML, mdIndexFile, baseDirectory, buildDirectory,
                                                      layoutFile, jsonFile);
                        break;
                     case DIRECTORY:
                        handleDirectory(ev, templateHTML, baseDirectory);
                        break;
                     case OTHER:
                        break;
                  }
               }
               key.reset();
               key = watcher.take();
            }
         }
      } catch (IOException | InterruptedException e) {
         System.err.println("An error occurred while the continuous building was running, the command will end now.");
         return 1;
      }
   }

   /**
    * Creates html files from md in subdirs, and translates all the images found
    *
    * @param templateHTML     the template html
    * @param currentDirectory the current directory
    * @param currentBuildDir  the current build dir
    *
    * @throws IOException the io exception
    */
   private void recursiveBuild(TemplateHTML templateHTML, File currentDirectory, File currentBuildDir)
           throws IOException {
      if (currentDirectory.listFiles() != null) {
         for (File f : currentDirectory.listFiles()) {
            if (f.getName().toLowerCase().endsWith(".md")) {
               if (!currentBuildDir.mkdir()) {
                  throw new IOException();
               }
               createHTMLPage(templateHTML, f, currentBuildDir);
            }
         }
         Util.copyImages(currentDirectory, currentBuildDir);
         for (File f : currentDirectory.listFiles()) {
            if (f.isDirectory() && !f.getName().equals("build")) {
               File futurBuildDir = new File(currentBuildDir.getPath() + "/" + f.getName());
               recursiveBuild(templateHTML, f, futurBuildDir);
            }
         }
      }
   }


   /**
    * Create html page from the given md file
    *
    * @param templateHTML    the template html
    * @param mdFile          the md file
    * @param targetDirectory the target directory
    *
    * @throws IOException the io exception
    */
   private void createHTMLPage(TemplateHTML templateHTML, File mdFile, File targetDirectory) throws IOException {
      String htmlContent;
      try {
         htmlContent = templateHTML.generatePage(mdFile);
      } catch (IOException e) {
         System.err.println("Error while reading the mdFile");
         throw e;
      }
      String fileName = "/" + mdFile.getName().substring(0, mdFile.getName().length() - 3) + ".html";
      File indexHtmlFile = new File(targetDirectory.getPath() + fileName);
      try (BufferedWriter writer = new BufferedWriter(
              new OutputStreamWriter(new FileOutputStream(indexHtmlFile), StandardCharsets.UTF_8))) {
         Util.writeFile(htmlContent, writer);
      } catch (IOException e) {
         System.err.println("Error while writing the html file");
         throw e;
      }
   }

   /**
    * Builds all files starting from the root directory
    *
    * @param templateHTML   the template html
    * @param mdIndexFile    the md index file
    * @param baseDirectory  the base directory
    * @param buildDirectory the build directory
    *
    * @throws IOException if there was a problem while building
    */
   private void buildAll(TemplateHTML templateHTML, File mdIndexFile, File baseDirectory, File buildDirectory)
           throws IOException {
      String indexContent;
      try {
         indexContent = templateHTML.generatePage(mdIndexFile);
      } catch (IOException e) {
         System.err.println("Error while reading the mdFile");
         throw e;
      }

      File indexHtmlFile = new File(buildDirectory.getPath() + "/index.html");
      try (BufferedWriter writer = new BufferedWriter(
              new OutputStreamWriter(new FileOutputStream(indexHtmlFile), StandardCharsets.UTF_8))) {
         Util.writeFile(indexContent, writer);
         Util.copyImages(baseDirectory, buildDirectory);
      } catch (IOException e) {
         System.err.println("Error while writing the html file");
         throw e;
      }

      for (File f : baseDirectory.listFiles()) {
         if (f.isDirectory() && !f.getName().equals("build")) {
            File futurBuildDir = new File(buildDirectory.getPath() + "/" + f.getName());
            recursiveBuild(templateHTML, f, futurBuildDir);
         }
      }
   }

   //Continuous development functions

   /**
    * Handles the changes to a md file
    *
    * @param event         the event
    * @param baseDirectory the base directory
    * @param templateHTML  the template html
    */
   private void handleMd(WatchEvent<Path> event, File baseDirectory, TemplateHTML templateHTML) throws IOException {
      WatchEvent.Kind<?> kind = event.kind();
      Path fileModified = baseDirectory.toPath().resolve(event.context());
      Path finalPathInMD = Util.generatePathInBuildDirectory(baseDirectory.toPath(), fileModified.toAbsolutePath());
      File fileHTML = new File(finalPathInMD.toString().replace(".md", ".html"));

      if (kind == StandardWatchEventKinds.ENTRY_CREATE) {
         if (event.context().toFile().length() > 0) {
            createHTMLPage(templateHTML, fileModified.toAbsolutePath().toFile(), finalPathInMD.getParent().toFile());
         }
      } else if (kind == StandardWatchEventKinds.ENTRY_MODIFY) {
         if (fileModified.toAbsolutePath().toFile().exists()) {
            fileHTML.delete();
            createHTMLPage(templateHTML, fileModified.toAbsolutePath().toFile(), finalPathInMD.getParent().toFile());
         }
      } else if (kind == StandardWatchEventKinds.ENTRY_DELETE) {
         fileHTML.delete();
      }
   }


   /**
    * Handle changes to the config and layout files
    *
    * @param event          the event
    * @param templateHTML   the template html
    * @param mdIndexFile    the md index file
    * @param baseDirectory  the base directory
    * @param buildDirectory the build directory
    * @param layoutFile     the layout file
    * @param jsonFile       the json file
    *
    * @return the template html
    *
    * @throws IOException the io exception
    */
   private TemplateHTML handleConfigAndLayout(WatchEvent<Path> event, TemplateHTML templateHTML, File mdIndexFile,
                                              File baseDirectory, File buildDirectory, File layoutFile, File jsonFile)
           throws IOException {
      WatchEvent.Kind<?> kind = event.kind();
      if (kind == StandardWatchEventKinds.ENTRY_MODIFY) {
         if (baseDirectory.toPath().resolve(event.context()).toAbsolutePath().toFile().exists()) {
            templateHTML = new TemplateHTML(layoutFile, jsonFile);
            if (buildDirectory.exists()) {
               try {
                  FileUtils.deleteDirectory(buildDirectory);
               } catch (IOException e) {
                  System.err.println("Build directory deletion failure.");
                  throw e;
               }
            }
            buildDirectory.mkdir();
            buildAll(templateHTML, mdIndexFile, baseDirectory, buildDirectory);
            return templateHTML;
         }
      } else if (kind == StandardWatchEventKinds.ENTRY_DELETE) {
         System.err.println("Error : if you delete or rename the config.json or layout.html files, the application " +
                            "will not work properly.");
         throw new IOException();
      }
      return templateHTML;
   }

   /**
    * Handle changes made to directories.
    *
    * @param event         the event
    * @param templateHTML  the template html
    * @param baseDirectory the base directory
    */
   private void handleDirectory(WatchEvent<Path> event, TemplateHTML templateHTML, File baseDirectory)
           throws IOException {
      WatchEvent.Kind<?> kind = event.kind();
      Path path = baseDirectory.toPath().resolve(event.context());
      if (kind == StandardWatchEventKinds.ENTRY_CREATE) {
         Path pathUtil = Util.generatePathInBuildDirectory(baseDirectory.toPath(), path.toAbsolutePath());
         recursiveBuild(templateHTML, path.toAbsolutePath().toFile(), pathUtil.toAbsolutePath().toFile());
      } else if (kind == StandardWatchEventKinds.ENTRY_DELETE) {
         Path pathUtil = Util.generatePathInBuildDirectory(baseDirectory.toPath(), path.toAbsolutePath());
         File file = pathUtil.toFile();
         file.delete();
      }
   }

   /**
    * Handle image.
    *
    * @param event         the event
    * @param baseDirectory the base directory
    */
   private void handleImage(WatchEvent<Path> event, File baseDirectory) throws IOException {
      WatchEvent.Kind<?> kind = event.kind();
      File source = baseDirectory.toPath().resolve(event.context()).toFile();
      File dest = Util.generatePathInBuildDirectory(baseDirectory.toPath(), source.toPath()).toFile();
      if (kind == StandardWatchEventKinds.ENTRY_CREATE) {
         FileUtils.copyFile(source, dest);
      } else if (kind == StandardWatchEventKinds.ENTRY_MODIFY) {
         if (event.context().toAbsolutePath().toFile().exists()) {
            dest.delete();
            FileUtils.copyFile(source, dest);
         }
      } else if (kind == StandardWatchEventKinds.ENTRY_DELETE) {
         dest.delete();
      }
   }


   /**
    * An enum that describes the file types handled by the continuous building
    */
   enum FileType {
      /**
       * An md file
       */
      MD,
      /**
       * The layout.html file
       */
      LAYOUT,
      /**
       * The config.json file
       */
      CONFIG,
      /**
       * A .jpg or .png image
       */
      IMAGE,
      /**
       * A directory (except the build directory)
       */
      DIRECTORY,
      /**
       * Any other file type
       */
      OTHER;

      /**
       * Gets file type from file.
       *
       * @param file          the file
       * @param rootDirectory the root directory
       *
       * @return the file type from file
       */
      public static FileType getFileTypeFromFile(File file, File rootDirectory) {
         if (file.isDirectory()) {
            return DIRECTORY;
         }
         String name = file.getName();
         switch (FilenameUtils.getExtension(name).toLowerCase()) {
            case "md":
               return MD;
            case "html":
               if (name.equals("layout.html") && file.getParentFile().getName().equals("template") &&
                   file.getParentFile().getParentFile().equals(rootDirectory)) {
                  return LAYOUT;
               }
               break;
            case "json":
               File parent = file.toPath().toAbsolutePath().toFile().getParentFile();
               if (name.equals("config.json") && parent.equals(rootDirectory)) {
                  return CONFIG;
               }
               break;
            case "png":
            case "jpg":
               return IMAGE;
         }
         return OTHER;
      }
   }

}